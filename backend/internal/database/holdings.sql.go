// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: holdings.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createHolding = `-- name: CreateHolding :one
INSERT INTO holdings (
    user_id,
    term,
    amount,
    yield_at_purchase,
    purchase_date,
    remaining_amount,
    face_value,
    purchase_price,
    security_type
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9
) RETURNING id, user_id, term, amount, yield_at_purchase, purchase_date, remaining_amount, face_value, purchase_price, security_type
`

type CreateHoldingParams struct {
	UserID          int32            `json:"user_id"`
	Term            string           `json:"term"`
	Amount          pgtype.Numeric   `json:"amount"`
	YieldAtPurchase pgtype.Numeric   `json:"yield_at_purchase"`
	PurchaseDate    pgtype.Timestamp `json:"purchase_date"`
	RemainingAmount pgtype.Numeric   `json:"remaining_amount"`
	FaceValue       pgtype.Numeric   `json:"face_value"`
	PurchasePrice   pgtype.Numeric   `json:"purchase_price"`
	SecurityType    pgtype.Text      `json:"security_type"`
}

func (q *Queries) CreateHolding(ctx context.Context, arg CreateHoldingParams) (Holding, error) {
	row := q.db.QueryRow(ctx, createHolding,
		arg.UserID,
		arg.Term,
		arg.Amount,
		arg.YieldAtPurchase,
		arg.PurchaseDate,
		arg.RemainingAmount,
		arg.FaceValue,
		arg.PurchasePrice,
		arg.SecurityType,
	)
	var i Holding
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Term,
		&i.Amount,
		&i.YieldAtPurchase,
		&i.PurchaseDate,
		&i.RemainingAmount,
		&i.FaceValue,
		&i.PurchasePrice,
		&i.SecurityType,
	)
	return i, err
}

const getHoldingByID = `-- name: GetHoldingByID :one
SELECT id, user_id, term, amount, yield_at_purchase, purchase_date, remaining_amount, face_value, purchase_price, security_type FROM holdings
WHERE id = $1
`

func (q *Queries) GetHoldingByID(ctx context.Context, id int32) (Holding, error) {
	row := q.db.QueryRow(ctx, getHoldingByID, id)
	var i Holding
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Term,
		&i.Amount,
		&i.YieldAtPurchase,
		&i.PurchaseDate,
		&i.RemainingAmount,
		&i.FaceValue,
		&i.PurchasePrice,
		&i.SecurityType,
	)
	return i, err
}

const getHoldingsByUser = `-- name: GetHoldingsByUser :many
SELECT id, user_id, term, amount, yield_at_purchase, purchase_date, remaining_amount, face_value, purchase_price, security_type FROM holdings
WHERE user_id = $1
ORDER BY purchase_date DESC
`

func (q *Queries) GetHoldingsByUser(ctx context.Context, userID int32) ([]Holding, error) {
	rows, err := q.db.Query(ctx, getHoldingsByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Holding{}
	for rows.Next() {
		var i Holding
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Term,
			&i.Amount,
			&i.YieldAtPurchase,
			&i.PurchaseDate,
			&i.RemainingAmount,
			&i.FaceValue,
			&i.PurchasePrice,
			&i.SecurityType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateHoldingRemainingAmount = `-- name: UpdateHoldingRemainingAmount :one
UPDATE holdings
SET remaining_amount = $2
WHERE id = $1
RETURNING id, user_id, term, amount, yield_at_purchase, purchase_date, remaining_amount, face_value, purchase_price, security_type
`

type UpdateHoldingRemainingAmountParams struct {
	ID              int32          `json:"id"`
	RemainingAmount pgtype.Numeric `json:"remaining_amount"`
}

func (q *Queries) UpdateHoldingRemainingAmount(ctx context.Context, arg UpdateHoldingRemainingAmountParams) (Holding, error) {
	row := q.db.QueryRow(ctx, updateHoldingRemainingAmount, arg.ID, arg.RemainingAmount)
	var i Holding
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Term,
		&i.Amount,
		&i.YieldAtPurchase,
		&i.PurchaseDate,
		&i.RemainingAmount,
		&i.FaceValue,
		&i.PurchasePrice,
		&i.SecurityType,
	)
	return i, err
}
